#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
============================================================
APP3 â€” AITA
------------------------------------------------------------
File: export.py

Description :
    Exporter un pack de tests (list[TestCase]) en :
      - JSON (audit, outillage)
      - Markdown (lecture recruteur)

RÃ´le :
    - Garantir des exports dÃ©terministes (ordre stable)
    - Produire des artefacts lisibles offline (R3)
    - Fallback-safe : pack vide => exports gÃ©nÃ©rÃ©s quand mÃªme

Contraintes :
    - DÃ©terministe (ordre stable)
    - Lisible recruteur (R3)
    - Fallback-safe

API :
    export_test_pack_json(testcases, out_path, *, logger=None) -> None
    export_test_pack_md(testcases, out_path, *, logger=None) -> None
============================================================
"""

from __future__ import annotations

# ============================================================
# ğŸ“¦ Imports
# ============================================================
import json
import logging
from pathlib import Path
from typing import Optional, Tuple

from vv_app3_aita.models import TestCase

_LOG = logging.getLogger(__name__)


# ============================================================
# ğŸ”§ Helpers
# ============================================================
def _ensure_parent_dir(path: Path) -> None:
    """CrÃ©e le dossier parent si nÃ©cessaire (idempotent)."""
    path.parent.mkdir(parents=True, exist_ok=True)


def _sort_key(tc: TestCase) -> Tuple[str, str]:
    """
    Stable ordering key.

    Sort order:
        1) requirement_id
        2) test_id
    """
    return (tc.requirement_id, tc.test_id)


def _validate_pack(testcases: list[TestCase]) -> None:
    """
    Valide le pack (audit proof).

    Raises:
        Exception: si un TestCase est invalide (tc.validate()).
    """
    for tc in testcases:
        tc.validate()


# ============================================================
# ğŸ”§ Fonctions principales (Exports)
# ============================================================
def export_test_pack_json(
    testcases: list[TestCase],
    out_path: str | Path,
    *,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    Export du pack de tests au format JSON.

    JSON schema (simple & stable):
    {
      "meta": {"count": N, "format": "vv-app3-aita.test-pack.v1"},
      "tests": [ {TestCase dict}, ... ]
    }

    Args:
        testcases: pack de tests Ã  exporter.
        out_path: chemin de sortie JSON (str ou Path).
        logger: logger optionnel (sinon logger module).

    Returns:
        None
    """
    log = logger or _LOG
    path = Path(out_path)

    _validate_pack(testcases)
    tests_sorted = sorted(testcases, key=_sort_key)

    payload = {
        "meta": {
            "count": len(tests_sorted),
            "format": "vv-app3-aita.test-pack.v1",
        },
        "tests": [
            {
                "test_id": tc.test_id,
                "requirement_id": tc.requirement_id,
                "title": tc.title,
                "description": tc.description,
                "preconditions": tc.preconditions,
                "steps": tc.steps,
                "expected_results": tc.expected_results,
                "source_ideas": tc.source_ideas,
            }
            for tc in tests_sorted
        ],
    }

    _ensure_parent_dir(path)
    path.write_text(
        json.dumps(payload, ensure_ascii=False, indent=2) + "\n",
        encoding="utf-8",
    )
    log.info("export_test_pack_json: wrote %s (%s tests).", str(path), len(tests_sorted))


def export_test_pack_md(
    testcases: list[TestCase],
    out_path: str | Path,
    *,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    Export du pack de tests au format Markdown (recruiter-friendly).

    Args:
        testcases: pack de tests Ã  exporter.
        out_path: chemin de sortie Markdown (str ou Path).
        logger: logger optionnel (sinon logger module).

    Returns:
        None
    """
    log = logger or _LOG
    path = Path(out_path)

    _validate_pack(testcases)
    tests_sorted = sorted(testcases, key=_sort_key)

    lines: list[str] = []
    lines.append("# Test Pack â€” APP3 AITA")
    lines.append("")
    lines.append("> Generated by vv-app3-aita (suggestion-only, auditable).")
    lines.append("")
    lines.append(f"- Count: **{len(tests_sorted)}**")
    lines.append("")

    if not tests_sorted:
        lines.append("## No tests generated")
        lines.append("")
        lines.append("The pack is empty. Check inputs (requirements / test ideas).")
    else:
        # Group by requirement_id
        current_req: Optional[str] = None
        for tc in tests_sorted:
            if tc.requirement_id != current_req:
                current_req = tc.requirement_id
                lines.append(f"---\n\n## Requirement: `{current_req}`\n")

            lines.append(f"### {tc.test_id} â€” {tc.title}")
            lines.append("")

            if tc.description:
                lines.append(tc.description.strip())
                lines.append("")

            # Preconditions
            lines.append("**Preconditions**")
            for p in tc.preconditions:
                lines.append(f"- {p}")
            lines.append("")

            # Steps
            lines.append("**Steps**")
            for idx, step in enumerate(tc.steps, start=1):
                lines.append(f"{idx}. {step}")
            lines.append("")

            # Expected
            lines.append("**Expected results**")
            for e in tc.expected_results:
                lines.append(f"- {e}")
            lines.append("")

            # Traceability (source ideas)
            if tc.source_ideas:
                lines.append("**Source ideas**")
                for sid in tc.source_ideas:
                    lines.append(f"- `{sid}`")
                lines.append("")

    _ensure_parent_dir(path)
    path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
    log.info("export_test_pack_md: wrote %s (%s tests).", str(path), len(tests_sorted))
