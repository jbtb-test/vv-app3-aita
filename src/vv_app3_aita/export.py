#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
============================================================
APP3 — AITA
------------------------------------------------------------
File: export.py

Rôle :
    Exporter un pack de tests (list[TestCase]) en :
      - JSON (audit, outillage)
      - Markdown (lecture recruteur)

Contraintes :
    - Déterministe (ordre stable)
    - Lisible recruteur (R3)
    - Fallback-safe (pack vide => exports générés quand même)

API :
    export_test_pack_json(testcases, out_path, *, logger=None) -> None
    export_test_pack_md(testcases, out_path, *, logger=None) -> None
============================================================
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Optional

from vv_app3_aita.models import TestCase

_LOG = logging.getLogger(__name__)


def _ensure_parent_dir(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def _sort_key(tc: TestCase) -> tuple[str, str]:
    # Stable ordering: requirement_id then test_id
    return (tc.requirement_id, tc.test_id)


def export_test_pack_json(
    testcases: list[TestCase],
    out_path: str | Path,
    *,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    Export test pack as JSON.

    JSON schema (simple & stable):
    {
      "meta": {"count": N, "format": "vv-app3-aita.test-pack.v1"},
      "tests": [ {TestCase dict}, ... ]
    }
    """
    log = logger or _LOG
    path = Path(out_path)

    # Validate (audit proof)
    for tc in testcases:
        tc.validate()

    tests_sorted = sorted(testcases, key=_sort_key)

    payload = {
        "meta": {
            "count": len(tests_sorted),
            "format": "vv-app3-aita.test-pack.v1",
        },
        "tests": [
            {
                "test_id": tc.test_id,
                "requirement_id": tc.requirement_id,
                "title": tc.title,
                "description": tc.description,
                "preconditions": tc.preconditions,
                "steps": tc.steps,
                "expected_results": tc.expected_results,
                "source_ideas": tc.source_ideas,
            }
            for tc in tests_sorted
        ],
    }

    _ensure_parent_dir(path)
    path.write_text(
        json.dumps(payload, ensure_ascii=False, indent=2) + "\n",
        encoding="utf-8",
    )
    log.info("export_test_pack_json: wrote %s (%s tests).", str(path), len(tests_sorted))


def export_test_pack_md(
    testcases: list[TestCase],
    out_path: str | Path,
    *,
    logger: Optional[logging.Logger] = None,
) -> None:
    """
    Export test pack as Markdown (recruiter-friendly).
    """
    log = logger or _LOG
    path = Path(out_path)

    for tc in testcases:
        tc.validate()

    tests_sorted = sorted(testcases, key=_sort_key)

    lines: list[str] = []
    lines.append("# Test Pack — APP3 AITA")
    lines.append("")
    lines.append("> Generated by vv-app3-aita (suggestion-only, auditable).")
    lines.append("")
    lines.append(f"- Count: **{len(tests_sorted)}**")
    lines.append("")

    if not tests_sorted:
        lines.append("## No tests generated")
        lines.append("")
        lines.append("The pack is empty. Check inputs (requirements / test ideas).")
    else:
        # Group by requirement_id
        current_req = None
        for tc in tests_sorted:
            if tc.requirement_id != current_req:
                current_req = tc.requirement_id
                lines.append(f"---\n\n## Requirement: `{current_req}`\n")

            lines.append(f"### {tc.test_id} — {tc.title}")
            lines.append("")
            if tc.description:
                lines.append(tc.description.strip())
                lines.append("")

            # Preconditions
            lines.append("**Preconditions**")
            for p in tc.preconditions:
                lines.append(f"- {p}")
            lines.append("")

            # Steps
            lines.append("**Steps**")
            for idx, step in enumerate(tc.steps, start=1):
                lines.append(f"{idx}. {step}")
            lines.append("")

            # Expected
            lines.append("**Expected results**")
            for e in tc.expected_results:
                lines.append(f"- {e}")
            lines.append("")

            # Traceability (source ideas)
            if tc.source_ideas:
                lines.append("**Source ideas**")
                for sid in tc.source_ideas:
                    lines.append(f"- `{sid}`")
                lines.append("")

    _ensure_parent_dir(path)
    path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
    log.info("export_test_pack_md: wrote %s (%s tests).", str(path), len(tests_sorted))
